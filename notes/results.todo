steelmil:
  smac wins but on  2 out 3 runs it found nothing.
  on 25 races it was sat
  on 5 races it  was unsat

  both times it was the last param that was tried that discriminating

                            prob038-steel
   method_opts2    races mean  sd    min max
   nsample, 4, 0,0 1     160.0  0.00 160 160
                   5     160.0  0.00 160 160
                   25    160.0  0.00 160 160
   smac,0          1     160.0  0.00 160 160
                   5     117.3 73.90  32 160
                   25    117.3 73.90  32 160
   uniform,0       1     160.0  0.00 160 160
                   5     152.3 13.28 137 160
                   25    160.0  0.00 160 160

Sonet:

Since the essence allows the  demand can be empty, this results in thing like this being Generated.

1093b67631b5e55bfde7d8c13b077aadbd0f14be568a0a17fed5aa9700d5205e8dfea28b55c1b6147aa06ce5ee8e99f841b806aeec7bc9ca62c7bb5acdb78a70.param

5 non Dominated model

total time
4 seconds  (0.01 minion)  on best 0064
20 seconds (1.56 minion)  on worst 0050


language Essence 1.3
letting nnodes be 16
letting nrings be 12
letting capacity be 10
letting demand be {}

with solution

letting network be mset({}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {})

wherehouse:
  after 5 mins  minion was not able to produce the param  (tried 10 times)

  /Users/bilalh/CS/instancegen/mchain/__/ns/param_gen

  Probably because the eprime has domains like this   (max 900 elements each with 30 values )
      matrix indexed by [int(1..n_stores * n_warehouses * n_upper)] of int(1..n_warehouses)

  look for better rules for
  cost : function (total) tuple (Int1, Int2) --> int(1..n_upper)


  idea

  (1)
  find cost : function (total) tuple (int(1..a), int(1..b)) --> int(1..c)

  (2)
  find costt1 : function (total)  int(1..a) --> int(1..c)
  find costt2 : function (total)  int(1..b) --> int(1..c)

  (3)
  find cost matrix indexed by [ int(1..a), int(1..b) ] of int(1..c)


  2-3-3

  (1) 729 solution   (2) 243 solutions

  cost be function((1, 1) --> 3, (1, 2) --> 3, (1, 3) --> 3, (2, 1) --> 3, (2, 2) --> 3, (2, 3) --> 2)

  each solution for 2 encodes  3 solutions   ( domsize(costt2) Choose domsize(costt1) ?)
  costt1 be function(1 --> 3, 2 --> 3) costt2 be function(1 --> 3, 2 --> 3, 3 --> 2)

  (1, 1) --> 3, (1, 2) --> 3,  (2, 1) --> 3, (2, 2) --> 3

  (1, 3) --> 3 (2, 3) --> 3
  (1, 3) --> 2 (2, 3) --> 3
  (1, 3) --> 2 (2, 3) --> 2


  1-2-4

  (1) 16 solution   (2) 64 solutions

  cost be function((1, 1) --> 4, (1, 2) --> 3)

  costt1 be function(1 --> 4) costt2 be function(1 --> 4, 2 --> 3)





