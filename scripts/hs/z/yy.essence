! ( (i,i) in defined(graph) ),
!( (fro[1] + (to[1] - fro[1])/2, fro[2] + (to[2] - fro[2])/2 ) in steps(i+1) )
!((d1,a) in defined(dist_except)) /\
!((d2,a) in defined(dist_except))
!(4 in x),
!(allocation[tank] in impossibleCargos[tank])
!(copper in contents(b)),
!(f in small /\ f in large)),
!(glass in contents(b)),
!(plastic in contents(b))
!(plastic in contents(b)) /\
!(plastic in contents(b)),
!(steel in contents(b)) /\
!(steel in contents(b)),
!(wood in contents(b)) /\
!({allocation[tank], allocation[neighbour]} in incompatibilities)
!=
!graph(c, t, e1)
!graph(c, t, e1) /\  !graph(c, e1, t)
!graph(c, t, e1) /\  !graph(c, e1, t),
!graph(i,i),
% grid[ l( l(i)[3] )[4,1]  , l( l(i)[3] )[4,2]  ]
(
( (
( ( (set (size 1) of int(1,2), set (size 1) of int(4,5) ),int(3,6) ), int(8,9))
( (int(1,2), int(4,5) ), int(8,9))
( (int(1,2), int(4,5) ), set (size 1) of int(8,9))
( (int(1,2), int(4,5))
( (int(10), int(11)),  int(12))
( (int(10), int(11)),  int(12)),
( (set (size 1) of int(1,2), set (size 1) of int(4,5) ), int(8,9))
( (set (size 1) of int(1,2), set (size 1) of int(4,5) ), set of int(8,9))
( (set (size 1) of set (size 1) of int(1,2) , int(4,5) ), int(8,9))
( (sum i : Index . toInt(s(i)=a) )=lam),
( (sum i : int(startingIndexes[ruleIndex]..(startingIndexes[ruleIndex] + colRules[column][ruleIndex] - 1) ) . grid[i][column]) = colRules[column][ruleIndex])
( (sum i : int(startingIndexes[ruleIndex]..(startingIndexes[ruleIndex] + rowRules[row][ruleIndex] - 1) ) . grid[row][i]) = rowRules[row][ruleIndex])
( gateOutput(gate) = gateFuncs(gate)([gateOutput(gateInpts(gate)[1]), gateOutput(gateInpts(gate)[2])])
( int(12)
( int(14), int(15) )
( int(15), int(16), int(17), int(18))
( int(4,5)
( int(5)
( int(8),int(3)),
( matrix indexed by [int(3..4)] of (int(1,2),int(3,4),int(5,6))
( matrix indexed by [int(3..4)] of int(1..7)
( set (minSize 1) of int(1,3), set (minSize 1) of (int(1,2), int(5)) ),
( set (minSize 1) of int(1,3), set (minSize 1) of (int(1,2), int(6)) )
( set (size 1) of int(5)
( set(size 1)  of int(5)
( set(size 1) of int(5)
((
(( ruleIndex = 1
((int(10), int(11)),  int(12)),
((ruleIndex = 1
((startingIndexes[ruleIndex] + colRules[column][ruleIndex] - 1) = nGrid
((startingIndexes[ruleIndex] + rowRules[row][ruleIndex] - 1) = nGrid
((sum i : dGrid . grid[i][column]) = (sum j : dRules . colRules[column][j]))
((sum i : dGrid . grid[row][i]) = (sum j : dRules . rowRules[row][j]))
((sum index : dGrid . clickMatrix[index][y] + clickMatrix[x][index]) - clickMatrix[x][y]) % colours
((sum index : dGrid . simplerClickMatrix[index][y] + simplerClickMatrix[x][index]) - simplerClickMatrix[x][y]) % colours
(10, function(3 --> {}, 2 --> {1},  1 --> {2,1} ), 33),
(11, function(3 --> {}, 2 --> {1},  1 --> {2,1} ), 55)
(14, (15, 16,17)),
(2,4,6) in x
(4,7) in x[1],
(5, 6, {7,8,9} )
(a in batch_attr(schedule((l,d1,s)))))
(a in batch_attr(schedule((l,d2,s)))))| <= 1,
(east(c) - west(c) = length(c) /\
(forAll (gateLinkedtoOutput, expectedOutput) in finalOutputs .
(forAll (x,y) : Cell . x in sx /\ y in sy <-> (x,y) in preImage(layout,s)) /\
(forAll gate : dGates .
(forAll i : Index .  i in range(f) <-> i in preImage(seq,m)) /\
(forAll j : int(1..k-1) . f(j+1) - f(j) = m + 1)
(fro[1] + (to[1] - fro[1])/2, fro[2] + (to[2] - fro[2])/2 ) in steps(i) /\
(i,j) in steps(0),
(int(1),int(2)),
(int(1),int(9),int(3), int(4)),
(int(10), int(11))
(int(10), int(11)),
(int(10..13), int(0..1))
(int(11),int(12))
(int(12), int(13))
(int(14), (int(15), int(16),int(17))),
(int(3),int(4))
(int(3),int(4)),
(int(4), (int(5),int(6)) )
(int(4),int(5))
(int(4),int(7)),
(int(4,5),int(6,1)),
(int(5),int(6))
(int(5),int(6)),
(int(5),int(6), set (size 3) of int(7,8,9) )
(int(5),int(6),int(7)),
(int(5),int(6),int(7), int(8))
(int(5),int(6),int(7), int(8)),
(int(6,7), int(8,9),int(0,9))
(int(7),int(8))
(int(7),int(8)),
(int(7,8),int(2,3))
(int(7,8),int(2,3)),
(int(9),int(10)),
(pair1_1, pair1_2) != (pair2_1, pair2_2)
(rb != rw) /\ (cb != cw) /\ (|rw - rb| != |cw - cb|)
(relation((1,2,3)))(1,_,_) = relation((2,3))
(s(i),s(i+1)) in network,
(set (size 1) of set (size 1) of int(18,19) , int(16,27) ),
(startingIndexes[ruleIndex] = 1
(sum (w,ts) in toSet(sched(_,p,_)) . toInt(t in ts)) <= 2,
(sum c in plugged(r) . (req_power(ctype(c))))
(sum c in preImage(curr,p) . credits(c)) >= minl,
(sum d : Index . square[d,d]) = s,
(sum d : Index . square[d,n+1-d]) = s
(sum e in defined(capacity) . (capacity(e))) * batch_size =
(sum i : int(0..n-1) . assign(3*i+1) / (assign(3*i+2)*10
(sum i : int(s..s+blksize(opt)-1) . toInt(usage(car(i),opt))) <= maxcars(opt)
(sum i in directChildrenMatrix[node] . |totalChildrenMatrix[i]|) = |totalChildrenMatrix[node]| - 1
(sum i in picked . weights(i) ) <= totalWeight
(sum i in setA . i) = (sum i in setB . i)
(sum i in setA . i*i) = (sum i in setB . i*i)
(sum i,j : dGridSize . clickMatrix[i][j]) <= (sum i,j : dGridSize . simplerClickMatrix[i][j])
(sum i,j : int(-1..1) . toInt((a+i,b+j) in alive)) <= 4,
(sum index : dSequnce . toInt(m[index] = element)) = lam
(sum index : dSequnce . toInt(seqA[index] != seqB[index])) = d
(sum index : int(1..hintMatrix[hintSet][hintSumIndex][2]) . (solutionGrid[ hintMatrix[hintSet][index][1] ][ hintMatrix[hintSet][index][2] ] ) ) = hintMatrix[hintSet][hintSumIndex][1]
(sum tank : dTanks . capacities[tank] * (allocation[tank] = cargo) ) >= volumeToShip[cargo]
(sum u in U' . s(u)) <= B,
(sum u in U' . v(u)) >= K
(sum w in range(plan(i) - (plan(i) intersect plan(i+1))) . w) =
(sum w in range(plan(i+1) - (plan(i) intersect plan(i+1))) . w)
(Week * Period * set (size 2) of Team)
(x1 = x2 \/ y1 = y2)
({1,2,3}, {3,4}, false, 3) = ({1,2,3},{3,4}, false, 3),
)
) <= 4
) \/ (
)) /\
),
+ (sum i : int(1..|even|-1) . distance({even(i),even(i+1)}))
+ assign(3*i+3))) = 1,
+ grid[ l( l(i)[3] )[4,1]  , l( l(i)[3] )[4,2]  ] ) /\ (
,
, !((a,b) in alive)
, (1,2)
, (1,3)
, (2,1)
, (2,2)
, (2,3)
, (2,3,4)
, (3,1)
, (3,2)
, (3,3)
, (3,4,5)
, (4,1)
, (4,2)
, (4,3)
, b1 != b2
, i <= plan_len .
, int(10)
, int(11)
, int(12)
, int(2..6)
, int(4)
, int(4..6)
, int(7)
, int(8)
, int(8..9)
, int(9)
, matrix indexed by [int(0..9)] of int(10..20)
, matrix indexed by [int(1,2)] of (int(55,99),int(28,31,32,33))
, o1 != o2
, pair1 != pair2
, plays_in(p,order(i))
, r1 != r2
, s1 != s2
, set (size 1) of int(4)
, set (size 1) of int(5)
, set (size 1) of int(6)
, set (size 1) of int(8)
, set (size 1) of int(9)
, w1 != w2
, w1 = w2
, { {2,3,4} }
, { {3,4,5} }
, |toSet(testcase)| = t
, |{a,b} intersect {1,n+2}| = 0
- (sum (s) in defined(schedule)(l,d2,_) .
->
-> s1 = s2),
-> |(sum (s) in defined(schedule)(l,d1,_) .
.
.  (x1,y1) in plan(t)
. !((a,b) in alive),
. (sum c : Index . toInt(!(m[r1,c] \/ m[r2,c]))) = 1
. (sum c : Index . toInt(!m[r,c])) = 11,
. (sum i : Index
. (sum i : Index . dist((s1(i),s2(i)))) >= minDist
. (sum i : Index . toInt(s1(i)!=s2(i))) = dist
. (sum i : Index . toInt(w1(i) = w2(i))) <= 4,
. (sum i,j : int(-1..1) . toInt((a+i,b+j) in alive)) != 3
. (sum p in sched . (p(b1) = p(b2))) <= 1
. (sum r : Index . toInt(!m[r,c])) = 11,
. arrive(p) <= i /\ leave(p) >= i
. colRules[column][ruleIndex] = 0
. forAll ruleIndex : dRules
. max(pair1) - min(pair1) != max(pair2) - min(pair2)
. rowRules[row][ruleIndex] = 0
. toInt(w1(i) = A /\ w2(9-i) = T \/
. |plugged(r1) intersect plugged(r2)| = 0
. |toSet(bibd(o1,_)) intersect toSet(bibd(o2,_))| = lambda_
/\
/\ !(((x1+x2)/2,(y1+y2)/2) in plan(t+1)),
/\ !((x1,y1) in plan(t+1))
/\ !((x2,y2) in plan(t))
/\ !(fro in steps(i+1))
/\ !(to in steps(i+1))
/\ ((x1+x2)/2,(y1+y2)/2) in plan(t)
/\ (to[1] <2 \/ to[1] > 4  -> to[2] >= 2 \/ to[2] <=4 )
/\ (to[2] <2 \/ to[2] > 4  -> to[1] >= 2 \/ to[1] <=4 )
/\ (x2,y2) in plan(t+1)
/\ fro in steps(i)
/\ fro in steps(i+1)
/\ path[i] = (fro, to)
/\ to  in steps(i)
/\ to  in steps(i+1)
1 < 2,
1 in a
1 in mms[1,4]
1 in x(2)
1 in x,
1,
2 < 3
2 in i
2 in x,
3 <= ( sum i,j : int(-1..1) . (a+i,b+j) in alive ) /\
3 in x
4
4 > max(x)
4 in x,
4,
6 in pain[1][3],
8 < max(x)
8 in pain[1][4]
<= capacity(h),
<= max(dist_except((d,a))),
<= max_power(model(r))
= quantity(m),
>= min(dist_except((d,a))) /\
>= separation({class(c1), class(c2)})
>= separation({class(c1), class(c2)}) \/
a - b = c,
a = x
a in req_attr(o),
allDiff(square),
allDiff(x)
Alphabet be domain int(65..90)
arrive, leave : function (total) Player --> Index
Attribute new type enum
B, K : int (1..)
b1 != b2
b1 != b2 /\ b1 + b2 = b3 -> ! ({b1,b2,b3} subsetEq s)
Batch be new type of size (sum e in defined(capacity) . (capacity(e)))
Batch be new type of size 10
batch_attr : function (total) Batch --> set of Attribute,
bins    new type enum,
bin_vol : int(1..),
blksize  : function (total) Option --> int(1..n_upperBound),
Block be new type of size b
branching on [z,x,y]
b[1] < 2,
b[2] > b[1],
c in plugged(r)
can_fly : relation of (Plane*Flight),
capacity : function (total) Colour --> int(0..)
capacity : function (total) tuple (Line,Day) --> int(1..),
capacity : int(1..),
Card  be domain int(1..n_cards),
carry_in : function (total) Plane --> Flight,
Cell be domain tuple (X,Y)
class      : function (total) Container --> Class,
Class     be domain int(1..n_classes),
Class  be domain int(1..n_classes),
codeWordLength : int(1..),
Colour be new type enum {red,green,blue}
contents : function Bin --> mset of Material
cost : function (total) tuple (Store, WHouse) --> int(1..n_upper)
credits : function (total) Course --> int(1..n_credits)
ctype        : function (total) Card  --> Type
c[1] = 1,
c[1] = a[1],
c[2] = b[3]
c[2] = b[3],
c[2] = {3,4},
c[3] = ({3,4},(3,true))
d >= line_on(o) /\ d <= line_off(o),
Day be domain int(1..10),
Day be domain int(1..n_days),
dict : function (total) Word --> function int(1..n_upper) --> Alphabet
dict(crossword(p1))(i1) = dict(crossword(p2))(i2),
Digit be domain int(1..9)
distance : function (total) set (size 2) of Farm --> int(0..),
dist_except : function tuple (Day,Attribute) -->
earlier : relation of (set of Attribute * set of Attribute)
earlier(batch_attr(schedule((l,d,s))),batch_attr(schedule((l,d,s+1))))
earlier(s1,s3))
earlier(s2,s3) ->
even : function int(1..n_farms+2) --> Farm
even(1) = 1,
exists  (x1,y1) in S .
exists f : function (total, injective) int(1..k) --> Index .
exists fro,to : Peg .
exists gateOutput : function (total) int(-1..numGates) --> bool .
exists j : int(i..i+maint_freq) . s(j) in maint
exists numberMapping : function (total, bijective) dSolutionGrid --> dSolutionGrid .
exists r in defined(model) .
exists startingIndexes : matrix indexed by [dRules] of dGrid
exists startingIndexes : matrix indexed by [dRules] of int(0..nGrid)
exists x,y : dGridSize .
exists {b1,b2} subsetEq toSet(graph(i,_)) .
f = function(1 --> -1, 2 --> 1)
f((1,4)) = 0
f1 = f2 - 6
f2(1) = -1
false = (({1,2,3}, {3,4}, false, 3) = ({1,2,4},{3,4}, true, 43)),
find  P: function(total,injective) queens --> squares
find  x : foobarbaz
find  x : int(0..9)
find  x : set (size    2) of set (size 4) of int(0..9)
find  x : set (size 1) of int(1)
find  x : set (size 2) of int(0..9)
find  x : set (size 2) of set (size 4) of int(0..9)
find a : int(0..9)
find a : set of int(1..4)
find a : tuple (int(0..9))
find a, b : set(size 3) of int(1..9)
find a,b,c,d: int(0..5)
find a,r,s: int(1..10)
find a,x,y : int(0..9)
find a: mset (size 3) of int(1..10)
find a: mset (size k) of int(n..m)
find alive : set of Cell
find allocation : matrix indexed by [dTanks] of dAllCargos
find arrangement : function (bijective) Index --> Index
find assign : function (total, surjective) Index --> Digit
find assignment : function (total) items --> bins
find b : tuple (int(0..9),int(3..8),set of int(3..4) )
find b: mset (size 3) of int(1..10)
find b: mset (size k) of int(n..m)
find batches : function (total) Batch --> mset of Lot,
find bibd : relation of (Obj * Block)
find black, white : set of Square
find c : set (size numCodeWords) of String
find c : set (size numOfCodeWords) of String
find c : set(size 2) of int(1..9)
find c : tuple (int(0..9), set of int(3..4))
find c : tuple (int(0..9), set of int(3..4),
find c : tuple (int(0..9), set of int(3..4), tuple(set of int(3..4), tuple(int(3..4), bool) ) )
find c: int(n..m)
find c: mset (size 3) of int(1..10)
find car : function (total) Slots --> Class
find clickMatrix : matrix indexed by [dGridSize, dGridSize] of dColours
find colour : function Bin --> Colour,
find col_per_slab: int(1..30)
find contents : function Bin --> mset (maxOccur 3) of Material
find CoverTest: mset (size b) of function (total) switches --> alphabet
find crossword : function (total) int(1..3) -->  int(1..3)
find crossword : function (total) Place --> Word
find curr : function (total) Course --> Period
find cut : function set of Order --> sizes
find directChildrenMatrix : matrix indexed by [dNodes] of set of dNodes
find divisors: function (total) int(1..n) --> set of int(1..n)
find E : set (size v) of matrix indexed by [dSequnce] of dElement
find f : function (int(1..3), int(1..3)) --> int(0..9)
find f : function (int(1..3), int(1..3)) --> set of int(0..9)
find f : function (minSize 1) int(1..9) --> int(1..9)
find f : function (total)  tuple (int(1..a), int(1..b)) --> (int(1..c), int(1,c))
find f : function (total)  tuple (int(1..a), int(1..b)) --> int(1..c)
find f : function (total)  tuple (int(1..a), int(1..b)) --> set of int(1..c)
find f : function (total) (int(1..3), int(1..4)) --> int(1..9)
find f : function (total) (int(1..3), int(4..5)) --> int(0..9)
find f : function (total) Index --> int(-1,1)
find f : function (total) Index --> Range
find f : function (total,injective)  tuple (int(1..a), int(1..b)) --> int(1..c)
find f : function int(1..9) --> int(1..9)
find faultyGates : function dGates --> bool
find foo: matrix indexed by [int(8, 3, 2, 7)] of bool
find fs :
find fs : function (total) int(a..b) --> T
find fs : matrix indexed by [int(1..5)] of set (size 2) of (int(10,11),int(12,13))
find fs : mset(size 2) of set (minSize 1) of function (total) Index --> int(-1,1)
find fs : set (minSize 1) of function (total) Index --> int(-1,1)
find fs : set (size 1) of
find fs : set (size 2) of (int(10,11),int(12,13))
find fs : set (size 2) of set (size 2) of function (total) Index --> set (size 2) of int(1,2,3)
find fs : set (size 3) of set (size 2) of (int(10,11),int(12,13))
find fs : set(maxSize a) of set (minSize b) of function (total) Index --> int(c,d)
find graph : relation (size 10)  of ( Dom * Dom * Dom  )
find graph : relation (size n*2) of (Vertex * Vertex)
find graph : relation (size num_edges)  of ( Colour * Vertex * Vertex  )
find graph : relation (size num_edges)  of (Vertex * Vertex  )
find graph: function (size  num_edges) (Vertex, Vertex ) --> Colour
find grid : matrix indexed by [dGrid, dGrid] of int(0..1)
find grid : matrix indexed by [int(1..bound),int(1..bound)] of dom
find hexagon : matrix indexed by [int(1..d),int(1..d)] of Value,
find hosts : set of Boat,
find i, j : int(0..5)
find layout : function Cell --> Shape
find m :
find m : matrix indexed by [int(4,5),int(10,11)] of set (minSize 1, maxSize 3) of int(6..8)
find m : matrix indexed by [int(4,5)] of set (minSize 1, maxSize 3)
find m : matrix indexed by [int(4,5)] of set (minSize 1, maxSize 3) of int(6..8)
find m: matrix indexed by [Index,Index] of bool
find mms: matrix indexed by [int(1..3),int(4..6)] of set (size 4) of int(1..9)
find mmt : matrix indexed by [int(1..3),int(4..6)] of tuple (bool,int(2..6))
find mmtm : matrix indexed by [ int(1..3)
find model   : function Rack --> Model,
find n : int(1..100)
find network : mset (size nrings) of set (maxSize capacity) of Nodes
find nodeBroadcastPower : matrix indexed by [dNodes] of dPower
find odd : function int(1..n_farms+2) --> Farm,
find open : function (total) Store --> WHouse
find ordCol: function (total) Order --> Colour
find order : function (total, bijective) Index --> Piece,
find orders : matrix indexed by [dNodes, dPeriods] of int(0..maxStock)
find ordSize: function (total) Order --> int(1..n_orderSize)
find p : partition (regular, size 2, partSize 2) from set of int(1..2)
find p : partition (size 2) from set of int(1..2)
find p : partition (size 3) from int(0..9)
find p : partition (size 3) from int(1..9)
find p : partition (size 3) from set (size 3) of int(1..5)
find p : partition from matrix indexed by [int(1..2)] of  int(1..2)
find packed : set of Items
find packing : function (total) int(1..5) --> int(1..5)
find pain :
find pain : (
find pain : matrix indexed by [int(1),int(2)] of
find pain : matrix indexed by [int(1)] of
find pain : matrix indexed by [int(1)] of function (total) int(1..2) --> int(-1,1)
find pain : matrix indexed by [int(1,2),int(1)] of
find pain : matrix indexed by [int(1,2)] of
find pain : matrix indexed by [int(1,2,3)] of
find pain : matrix indexed by [int(1..2),int(2..3)] of
find pain : matrix indexed by [int(1..2),int(3)] of
find pain : matrix indexed by [int(1..2)] of
find pain : matrix indexed by [int(1..3)] of
find pain : tuple (
find pain : tuple ( tuple ( matrix indexed by [int(1..2)] of int(6,8)  ) )
find pain: matrix indexed by [int(1, 2)] of (int(4, 5), int(10, 11))
find path : matrix indexed by [int(0..maxSteps-1)] of (Peg, Peg)
find path : matrix indexed by [int(0..maxSteps-1)] of function (size 1)  Peg --> Peg
find picked: set(maxSize n, minSize 1) of int(1..n)
find plan : function int(1..|board|) --> set of Hole,
find plan: function int(1..(totalWater+1)**nBuckets)--> State
find plan: function int(1..(total_water+1)**n_buckets) --> State
find plan_len: int(1..(total_water+1)**n_buckets)
find quasigroup : matrix indexed by [dom,dom] of dom
find r : relation (size 3) of (int(0..9) * bool)
find r : relation (size 5) of (int(0..3) * int(0..3))
find r : relation of (int(0..9) * int(0..9))
find r : relation of (int(1..5) * int(1..5) * int(1..5))
find route : function (total) Plane --> function int(1..n_flights) --> Flight
find rs : set(size 2) of relation of (int(0..3) * int(0..4))
find s : function (total, bijective) int(1..n) --> Num,
find s : matrix indexed by [int(0..4)] of (int(1..4), set of int(4,3))
find s : set (minSize 1) of (int(1..2), int(1..2))
find s : set (minSize 1,maxSize 3) of (int(1..4), set of int(4,3))
find s : set (minSize 1,maxSize 5) of set (minSize 2,maxSize 3) of int(1..5)
find S : set (minSize 2) of (int(1..4), int(1..4))
find s : set (minSize 2) of relation (minSize 1) of (int(1..2) * int(1..2))
find s : set (size 2 ) of Peg
find s : set (size 2 ) of set (minSize 3) of int(1..4)
find s : set (size n) of
find s : set of int(0..9)
find s : set of set (minSize 1, maxSize 3) of int(1..4)
find s1,s2 : set of int(0..9)
find s: set (size 2) of bool
find s: set (size 2) of set (size 1) of set (minSize 2, maxSize 3) of int(1..4)
find sched :
find sched : mset (size w) of partition (regular, size g) from Golfers
find sched : partition from Tasks
find sched : set (size n_periods) of function (total) Boat --> Boat
find sched : set (size w) of partition (regular, size g) from Golfers
find schedule : function (total, injective) tuple (Line,Day,Slot) --> Batch
find schur : partition (size n_boxes) from Ball
find se : set (minSize 1) of VCol
find seq : function (total) int(1..3) --> int(-1,1)
find seq : function (total) int(1..n) --> int(-1,1)
find seq : function (total, surjective) seqIndex --> int(1..n)
find seq: function(total,surjective) Index --> Num
find setA: set (size n/2) of dNum
find setB: set (size n/2) of dNum
find sets : matrix indexed by [int(1..nb)] of set (size 3) of int(1..n)
find sf : set (maxSize 3) of function (total)  tuple (int(1..a), int(1..b)) --> int(1..c)
find solutionGrid : matrix indexed by [dSolutionGrid, dSolutionGrid] of dSolutionGrid
find square : matrix indexed by [Index,Index] of Value,
find steps : set of Peg
find steps: function(total) Num --> set (minSize 1, maxSize 32) of Peg
find stock : matrix indexed by [dNodes, dAllPeriods] of int(0..maxStock)
find stuff : function (total) sizes --> int (1..n_colours)
find stuff : set of sizes
find Ticks : set (size n) of int(0..bound)
find totalChildrenMatrix : matrix indexed by [dNodes] of set of dNodes
find totalCost   : int(0..1000)
find totalCost_a : int(0..1000)
find totalCost_b : int(0..1000)
find U' : set of U
find valid :  function (total) int(1..3) --> VCol
find valid : function (total) int(1..3) --> VCol
find valid : set (minSize 1) of function (total) int(1..3) --> (VCol,PCol)
find valid : set (minSize 1) of function (total) int(1..3) --> VCol
find valid : set (minSize 1) of function (total) int(4..5) --> (int(6,7),int(9))
find valid : set of function (total) Road --> (VCol,PCol)
find var1: matrix indexed by [int(5..8)] of partition from int(2..4)
find west,  east  : function (total) Container --> X,
find words : set of function (total) Index --> Base
find x :
find x : bool
find x : digit
find x : e
find x : function (total) int(1..2) --> set of int(1..2)
find x : function (total, surjective) int(1..4) --> int(1..3)
find x : int(-100000..100000)
find x : int(0..10)
find x : int(0..100)
find x : int(0..1000)
find x : int(0..10000)
find x : int(0..50)
find x : int(0..9)
find x : int(0..90)
find x : int(0..a!)
find x : int(1..1000)
find x : int(1..5)
find x : int(1..9)
find x : matrix indexed by [int(1..2),int(1,2)] of int(6..8)
find x : matrix indexed by [int(1..2),int(1,2)] of set(minSize 1) of int(6,7,8)
find x : matrix indexed by [int(1..2),int(1,2)] of set(minSize 1) of int(6..8)
find x : matrix indexed by [int(1..2)] of (int(3,5), int(6,7),int(9))
find x : matrix indexed by [int(1..2)] of (set (minSize 1) of int(3,5), int(6,7),int(9))
find x : matrix indexed by [int(1..2)] of set(minSize 1) of (int(4,5,6),int(7,8,9))
find x : matrix indexed by [int(1..2)] of set(minSize 1) of int(6..8)
find x : mset (maxSize 3) of int(1..3)
find x : mset (minSize 2, maxOccur 3 ) of int(0..9)
find x : mset (minSize 2, maxSize 6) of int(0..9)
find x : mset (minSize 6, maxSize 12, minOccur 2, maxOccur 4 ) of int(0..6)
find x : mset (size 3) of int(2)
find x : mset (size 4) of int(0..9)
find x : mset (size 4) of mset (size 3) of int(0..9)
find x : mset (size 4) of mset (size 3) of mset (size 2) of int(0..9)
find x : mset (size 4) of mset (size 3) of mset (size 2) of mset (size 2) of int(0..9)
find x : mset (size 4, minOccur 2 ) of int(0..9)
find x : mset (size 5) of int(4..9)
find x : mset (size 5, minOccur 2, maxOccur 3 ) of int(0..9)
find x : mset (size 6) of int(4..9)
find x : partition (regular, size 4, partSize 3) from int(1..12)
find x : relation (maxSize 3) of (int(1..3) * int(1..3) * int(1..3))
find x : relation (minSize 1) of (VCol * PCol)
find x : relation (minSize 2) of (int(1) * int(4) * int(1,7))
find x : relation (size 12) of (int(1..2) * int(4..6) * int(1,7))
find x : relation of (int(1..4) * int(1..3))
find x : relation of (int(1..9) * int(1..9))
find x : set (maxSize 1) of int(0..9)
find x : set (maxSize 2) of int(0..9)
find x : set (maxSize 2) of int(0..9+1+4)
find x : set (maxSize 7) of
find x : set (minSize 1) of set (minSize 1) of int(1..2)
find x : set (minSize 1) of tuple (set (size 2) of int(6,7))
find x : set (minSize 1) of tuple (set (size 2) of int(6,7), int(1,3), set (size 1) of int(9))
find x : set (minSize 1) of V
find x : set (minSize 1, maxSize 4) of int(0..9)
find x : set (minSize 2) of int(0..6)
find x : set (minSize 2) of int(4..6)
find x : set (minSize 2) of tuple (int(2,3),int(4,5),int(6,7))
find x : set (size 1) of matrix indexed by [int(0..2)] of int(2..4)
find x : set (size 2) of int(1..5)
find x : set (size 2) of relation (minSize 1) of (int(1..2) * int(3))
find x : set (size 3) of int(0..9)
find x : set (size 4) of int(0..9)
find x : set (size 4) of set (minSize 1, maxSize 3) of int(0..9)
find x : set (size 4) of set (size 3) of int(0..9)
find x : set (size 4) of set (size 3) of set (minSize 1, maxSize 2) of int(0..9)
find x : set (size 4) of set (size 3) of set (size 2) of int(0..9)
find x : set (size 4) of set (size 3) of set (size 2) of set (minSize 1, maxSize 2) of int(0..9)
find x : set (size 4) of set (size 3) of set (size 2) of set (size 2) of int(0..9)
find x : set (size 5) of int(4..9)
find x : set (size 6) of int(0..9)
find x : set (size 6) of set (size 4) of int(0..9)
find x : set (size xSize) of int(0..9)
find x : set of (int(1..4), int(1..3))
find x : set of int(0..5)
find x : set of int(0..9)
find x : set of int(1..2)
find x : set of int(a..b)
find x : set of relation (size 2)  of (int(1..2) * int(3,4))
find x : set(size 1) of set (minSize 1, maxSize 2) of set (minSize 1, maxSize 2) of int(2..3)
find x : set(size 2) of relation  of (int(1..2) * int(3))
find x : set(size 2) of relation (minSize 1) of (int(1..2) * int(3))
find x : set(size 2) of relation (size 2)  of (int(1..2) * int(3,4))
find x : sizes
find x, y : function (total) Square --> Index
find x,y : e
find x,y : int(-9..9)
find x,y : set (minSize 2, maxSize 4) of int(1..3)
find x,y,z: int(1..9)
find x,y,z:int(1..9)
find x: int(6, 1)
find x: matrix indexed by [digits, digits] of digits
find x: mset (minSize 2, maxOccur 3) of int(0..9)
find x: mset (minSize 2, maxSize 6) of int(0..9)
find x: set (maxSize 4) of int(0..9)
find x: set (size 2) of relation of (int(1..2) * int(3))
find x: set (size 2) of set of int(1)
find x: set of int(0..9)
find y  :
find y  : (  (int(1), set (size 2) of int(2,3), int(4), (int(5),int(6), set (size 3) of int(7,8,9) )))
find y  : (int(1),(int(2),(int(3),int(4))))
find y  : tuple ( int(1..4), tuple( int(1..3), int(2..5), int(3..6) ) )
find y : digit
find y : e(bar..baz)
find y : int(0..100)
find y : int(0..1000)
find y : int(0..20)
find y : int(0..9)
find y : int(1..9)
find y : int(3..7)
find y : mset (size 3) of int(1..5)
find y : mset (size 3) of int(3..7)
find y : set (maxSize 3) of int(1..5)
find y : set (minSize 2) of int({8,3} union {2,7})
find y : set (size 3) of int(1..5)
find y : set (size 3) of int(3..7)
find y : set (size 4) of int(2..7)
find y : set (size 7) of int(0..9)
find y,z : int(0..100)
find y:
find y: matrix indexed by [int(1,2)] of (int(10,11),int(12,13) )
find z : int(1..9)
forAll ((p1,p2),(i1,i2)) in inter . inter((p2,p1)) = (i2,i1),
forAll ((p1,p2),(i1,i2)) in toSet(inter) .
forAll ((x1,y1),(x2,y2)) in range(moves) . |x1-x2| = 2 /\ |y1-y2| = 0 \/
forAll (a,b) : Cell
forAll (a,b) in alive .
forAll (c,e1) in toSet(graph(_, i, _) ) .
forAll (c,e1) in toSet(graph(_, _, i) ) .
forAll (d,a) in defined(dist_except) .
forAll (l,d,s) in defined(schedule) .
forAll (o,q) in batches(schedule((l,d,s))) .
forAll (os,cut_os) in toSet(cut) . (sum o in os . ordsize(o)) <= cut_os
forAll (os,cut_os) in toSet(cut) . (sum o in os . ordSize(o)) <= cut_os,
forAll (rb,cb) in black . forAll (rw,cw) in white .
forAll (t,((x1,y1),(x2,y2))) in moves
forAll (u,v) in defined(graph) .
forAll (u2,v2) in defined(graph), u2 = v /\ v2 != u .
forAll (x,y) in form(s) . layout((min(sx) + x,min(sy) + y)) = s,
forAll b : Batch . forAll (o,q) in batches(b) .
forAll b : Batch . forAll a in batch_attr(b) . exists (o,q) in batches(b) .
forAll b : Bin . b in defined(colour) <-> b in defined(contents),
forAll b : Bucket .
forAll b in defined(colour) . colour(b) = blue ->
forAll b in defined(colour) . colour(b) = green ->
forAll b in defined(colour) . colour(b) = red ->
forAll b in defined(colour) . copper in contents(b) ->
forAll b in defined(colour) . glass in contents(b) ->
forAll b in defined(colour) . wood in contents(b) ->
forAll b in defined(colour) . |contents(b)| <= capacity(colour(b)),
forAll b1,b2 : Boat
forAll bl : Block . |toSet(bibd(_,bl))| = k,
forAll boxColumn, boxRow : int(1..gridSize) .
forAll c : Card .
forAll c : Class . |preImage(car,c)| = quantity(c),
forAll c : Container . (east(c) - west(c) = width(c) /\
forAll c : Index
forAll c : Index . (sum r : Index . square[r,c]) = s,
forAll c in defined(layout) . c in grid,
forAll c1, c2 : Container . c1 != c2 ->
forAll c1, c2 : Container . c1 != c2 -> west(c1) != west(c2) \/
forAll c1,c2 : Course . prereq(c1,c2) -> curr(c1) < curr(c2),
forAll cargo : dCargos .
forAll childNode in directChildrenMatrix[node] .
forAll col : dom . allDiff(quasigroup[.., col]),
forAll column : dGrid .
forAll d : Digit . (sum i : Index . (assign(i) = d)) <= (n+1)/3
forAll element : dElement .
forAll f : Farm . f != 1 <-> (f in small \/ f in large /\
forAll f : Flight . exists p : Plane . f in range(route(p)),
forAll f in fs .
forAll f in fs . f(1) != -1
forAll f in sf .
forAll f2 in f .
forAll gridColumn, gridRow : int(0..gridSize-1) .
forAll group1 in parts(week1) .
forAll group2 in parts(week2) .
forAll hintSet : dHintGrid .
forAll i : Clue .  (
forAll i : dLeaves .
forAll i : dNodes .
forAll i : Dom .
forAll i : dom . quasigroup[i,i] = i,
forAll i : dSolutionGrid . allDiff(solutionGrid[..][i]) /\ allDiff(solutionGrid[i][..])
forAll i : Index
forAll i : int(0..maxSteps-1) .
forAll i : int(1..(total_water+1)**n_buckets)
forAll i : int(1..(total_water+1)**n_buckets) ,
forAll i : int(1..2) .
forAll i : int(1..3) .
forAll i : int(1..3) . |f(tuple(i,i))| = i + i
forAll i : int(1..n) .
forAll i : int(1..|plan|) . i in defined(plan),
forAll i : int(2..4) .
forAll i : int(numLeaves+1..numNodes) .
forAll i : set (size 2) of int(3..5) .
forAll i : Vertex .
forAll i in f(2) . x >= i
forAll i in fs .
forAll i in parts(p) . x >= |i|
forAll i in parts(p) . |i| < 5
forAll i in s .
forAll i in toSet(f) .
forAll i in toSet(x) . i[1] != i[2] /\ i[2] != i[3]
forAll i in x . i > 4
forAll i in x . true,
forAll i, j :  Vertex , i != j .
forAll i, j :  Vertex, i != j .
forAll i, j : Vertex .
forAll i,j : dNodes .
forAll i,j : dom . quasigroup[i,j] = i <-> quasigroup[j,i] = i
forAll i,j : dom . quasigroup[quasigroup[quasigroup[j,i],j],j] = i,
forAll i,j : seqIndex , i < j .
forAll i,j in x , i != j . i+j < y
forAll i2 : int(1..d - |o - r2|) . r1 != r2 \/ i1 != i2 ->
forAll j : int(0..1) .
forAll j : int(1..i) .
forAll j : int(2..4), (i,j) != hole .
forAll j : int(5..6) .
forAll j in i .
forAll l : Line . forAll a : Attribute . forAll d1,d2 : Day .
forAll l : Line . forAll d : Day . forAll s : int(1..n_slots-1) .
forAll m : Material . (sum b in defined(contents) . freq(contents(b),m))
forAll m : Num .
forAll m in E .
forAll neighbour in neighbours[tank] .
forAll node : dNodes .
forAll o  : Obj   . |toSet(bibd(o,_ ))| = r,
forAll o : Order . (sum b in defined(batches) .
forAll o : Order . exists os in defined(cut) . o in os,
forAll o1, o2 : Obj
forAll opt : Option .
forAll os in defined(cut) . (sum o in os . ordCol(o) ) <= col_per_slab
forAll os in defined(cut) . (sum o in os . ordSize(o)) <= cut(os),
forAll os1, os2 in defined(cut), os1 != os2 . |os1 intersect os2| = 0,
forAll p : int(1..3) . |dict(crossword(p))| < 3
forAll p : Period . (sum c in preImage(curr,p) . credits(c)) <= maxl /\
forAll p : Period . |preImage(curr,p)| <= maxc /\ |preImage(curr,p)| >= minc
forAll p : Place . |dict(crossword(p))| = length(p),
forAll p : Plane . (carry_in(p), route(p)(1)) in network,
forAll p : Plane . forAll a in range(route(p)) . tuple (a) in can_fly(p,_),
forAll p : Player .
forAll p : Player . plays_in(p,arrive(p)),
forAll p : Player . plays_in(p,leave(p)),
forAll p in sched .
forAll p in sched . forAll h in hosts . (sum b in preImage(p,h) . crew(b))
forAll p in sched . forAll h in hosts . p(h) = h,
forAll p in sched . range(p) subsetEq hosts,
forAll p1,p2 : Place . crossword(p1) =  crossword(p2) -> p1 = p2
forAll p1,p2 : Plane . |range(route(p1)) intersect range(route(p2))| = 0,
forAll pair in demand . exists ring in network . pair subsetEq ring
forAll pair1, pair2 : set (size 2) of int subsetEq Ticks
forAll pair1_1, pair1_2 in Ticks , pair1_1 < pair1_2 .
forAll pair2_1, pair2_2 in Ticks , pair2_1 < pair2_2 .
forAll q1, q2 : Index , q1 < q2 .
forAll q_1,q_2 in queens, q_1 != q_2 .
forAll r : Index
forAll r : Index . (sum c : Index . square[r,c]) = s,
forAll r : int(1..d) . (sum i : int(1..d - |o - r|) .
forAll r : int(1..d) . (sum i : int(1..d - |o - r|) . hexagon[r,i]) = s,
forAll r in defined(model) .
forAll r1, r2 in defined(model)
forAll r1,r2 : Index
forAll r1,r2 : int(1..d) . forAll i1 : int(1..d - |o - r1|) .
forAll row : dGrid .
forAll row : dom . allDiff(quasigroup[row, ..]),
forAll s : int(1..n_cars+1-blksize(opt)) .
forAll s : Shape . exists sx : set of X . exists sy : set of Y .
forAll s : Shape . |form(s)| = |preImage(layout,s)|
forAll s : Square . x(s) + s < container_size /\ y(s) + s < container_size,
forAll s in c . forAll a : Character .
forAll s in range(dict) . forAll i : int(1..|s|) . i in defined(s)
forAll s in range(plan) .
forAll s in range(plan) . (sum b : Bucket . s(b) )  = totalWater,
forAll s in range(plan) . forAll h in s . h in board,
forAll s in range(route) . forAll i : int(1..n_flights - maint_freq) , i <= |s| - maint_freq .
forAll s in range(route) . forAll i : int(1..n_flights) , i <= |s|-1 .
forAll s in range(route) . forAll i : int(1..|s|) . i in defined(s),
forAll s1 : set of Attribute . earlier(s1,s1),
forAll s1, s2 in c
forAll s1, s2 in c, s1 != s2
forAll s1,s2 : set of Attribute . (earlier(s1,s2) /\ earlier(s2,s1)
forAll s1,s2 : Square , s1 != s2 .
forAll s1,s2,s3 : set of Attribute . (earlier(s1,s2) /\
forAll seqA, seqB in E .
forAll setA : int(1..nb-1) .
forAll setB : int(setA+1..nb) .
forAll simplerClickMatrix : matrix indexed by [dGridSize, dGridSize] of dColours .
forAll t : dPeriods .
forAll t : int(1..|plan|-1) . |plan(t)| - |plan(t+1)| = 1,
forAll t : Team . forAll p : Period .
forAll t : Team . forAll w : Week . exists (p,ts) in toSet(sched(w,_,_)) . t in ts,
forAll t1,t2 : Team , t1 != t2 . |toSet(sched(_,_,{t1,t2}))| = 1
forAll tank : dTanks .
forAll tuple (t) in  toSet(graph(c, i, _) )  , t != e1 .
forAll tuple (t) in ( toSet(graph(c, i, _) ) union toSet(graph(c, _, i) )  ) , t != e1 .
forAll v__101, blah, v__1 : int(0..9) .
forAll w in words . |preImage(w,C)| + |preImage(w,G)| = 4,
forAll w1,w2 in words
forAll week1 in sched .
forAll week2 in sched , week1 != week2 .
forAll y in x .  y != 4
forAll y in x . (sum i in y . i) = 2
forAll { (x1, y1), (x2,y2) } subsetEq s .
forAll {(c1,v1), (c2,u2)} subsetEq S .
forAll {f1,f2} subsetEq  a - b .
forAll {pair1_1, pair1_2} subsetEq Ticks .
forAll {pair2_1, pair2_2} subsetEq Ticks , (pair1_1, pair1_2) != (pair2_1, pair2_2) .
forAll {week1, week2} subsetEq sched .
form : function (total) Shape --> set of Cell
freq(contents(b),wood) <= 1,
freq(contents(b),wood) <= 2,
freq(y, x) = 2
fro in steps(i)   /\ !(fro in steps(i+1) )  /\
fs = { s, s}
function (total)
function (total) Index --> T
function (total) int(1..2) --> int(-1,1),
function (total) int(a..b) --> T
function( 3 --> {1,2}, 2 --> {1,3},  1 --> {2,1} ),
function( 3 --> {3,2}, 1 --> {2,1},  2 --> {2,3} )
gateOutput(-1) = false
gateOutput(0) = true
gateOutput(gate) = faultyGates(gate)  )
gateOutput(gateLinkedtoOutput) = expectedOutput
given  a, b, c : int(1..30)
given  a, b, c : int(1..6)
given a : int
given a : int(0..9)
given a : relation of (int(1..9) * int(1..9))
given a : set (maxSize 3) of int(0..9)
given a : set (maxSize 3) of set (size 4) of int(0..9)
given a : set (size 2) of int(0..9)
given a : set (size 2) of set (size 4) of int(0..9)
given a : set (size 4) of int(0..5)
given a : set (size aSize) of int(0..5)
given a,b : set of int(0..5)
given a,b,c,d,e,f:int
given a,b,c,d:int
given a,b:int
given a: set (size 4) of int(0..9)
given aSize, bSize, xSize : int
given b : int(0..9)
given b : int(1..)
given b : set (size 3) of int(0..5)
given b : set (size bSize) of int(0..5)
given board, init, goal : set of Hole
given bound : int(1..100)
given c : int(..9)
given capacities : matrix indexed by [dTanks] of int(1..)
given capacity : function (total) WHouse --> int(1..n_upper),
given capacity, crew : function (total) Boat --> int(1..n_upper)
given Character new type enum  ,
given Character new type enum,
given children : matrix indexed by [dNodes] of set of dNodes
given colours : int(1..)
given colours : int(1..10)
given colRules : matrix indexed by [dGrid, dRules] of int(0..)
given current_assignment : function (total) processes --> machines
given d : int(1..)
given d : int(1..9)
given deck_width, deck_length, n_containers, n_classes : int(1..)
given demand : matrix indexed by [dLeaves, dPeriods] of int(0..)
given demand : set of set (size 2) of Nodes
given dict : function (total) int(1..3) --> function int(1..2) --> int(65..90)
given dist : function (Character, Character) --> int(0..maxDist),
given dom  new domain int
given duration : function (total) Piece --> int(1..),
given e new type enum
given e1,e2,e3 : foobarbaz
given end : Peg
given finalOutputs : function dGates --> bool
given g : function (total) (int(1..3), int(1..4)) --> int(1..9)
given gateFuncs : function (total) dGates --> (function matrix indexed by [int(1..2)] of bool --> bool)
given gateInpts : function (total) dGates --> matrix indexed by [int(1..2)] of int(-1..numGates)
given grid : set of Cell,
given gridSize : int(1..)
given hintMatrix : matrix indexed by [dHintGrid, int(1..hintSumIndex), dHintFormat] of int(0..)
given holdingCost : matrix indexed by [dNodes] of int(0..)
given hole, end: Peg
given impossibleCargos : matrix indexed by [dTanks] of set of dAllCargos
given incompatibilities : set of set (size 2) of dCargos
given indexSize: int
given initialNode : int(1..)
given items   new type enum,
given Items new type enum,
given k : int(1..5)
given k : int(2..5)
given k,b,t: int(1..), g: int(2..)
given l : function (total,injective) Clue  --> (Type, Arg, Arg, Postion  )
given lam : int(1..)
given length : function (total) Place --> int(1..n_upper),
given linkCosts : matrix indexed by [dNodes, dNodes] of dPower
given lookup : function (size 76) Peg --> Peg
given m : matrix indexed by [int(1..28)] of (int, int, int, int)
given machines  new type enum
given maxHintCells : int(1..)
given maxPower : int(1..)
given maxRules : int(1..)
given maxStock : int(1..)
given max_power    : function (total) Model --> int(1..5000),
given N    : int
given n : int
given n : int(1..)
given n : int(1..100)
given n : int(1..20)
given n : int(1..30)
given n,a,b : int
given n,a,b : int(0..100)
given n,m,k: int
given n: int(1..)
given neighbours : matrix indexed by [dTanks] of set of dTanks
given network : relation of (Flight*Flight),
given nGrid : int(1..)
given nnodes, nrings, capacity : int(1..)
given nnodes, nrings, capacity : int(1..100)
given numCargos : int(2..)
given numClues : int(1..bound**2)
given numGates : int(1..)
given numHints : int(1..)
given numLeaves : int(1..)
given numNodes : int(1..)
given numPeriods : int(1..)
given nums : set of int
given numTanks : int(1..)
given n_balls, n_boxes : int(1..)
given n_boats, n_periods : int(1..10)
given n_boats, n_periods : int(1..100)
given n_cars, n_classes, n_options, n_upperBound : int(1..)
given n_colours : int (1..10)
given n_colours, n_orders, col_per_slab, n_orderSize : int(1..)
given n_colours, n_orders: int(1..)
given n_colours, n_orders: int(1..20)
given n_colours: int(1..30)
given n_farms, capacity : int(1..)
given n_flights, n_planes, maint_freq : int(1..)
given n_flights, n_planes: int(1..20)
given n_models, n_types, n_cards, n_racks : int(1..5000)
given n_orders, n_lines, n_days, n_slots, batch_size: int(1..),
given n_orders: int(1..20)
given n_orders: int(1..30)
given n_orderSize: int(1..30)
given n_periods, maxl, minl, n_courses, maxc, minc, n_credits : int(1..)
given n_pieces, n_players : int(1..)
given n_places, n_words : int(1..100)
given n_roads : int(1..)
given n_roads : int(1..20)
given n_teams : int(1..)
given n_upper : int
given n_upper : int(1..100)
given n_upper, n_stores, n_warehouses : int(1..)
given ordsize : function (total) Order --> int(1..)
given ordsize : function (total) Order --> int(1..10)
given ordsize : function (total) Order --> int(1..10),
given ordSize : function (total) Order --> int(1..n_orderSize),
given prereq : relation of (Course*Course),
given procCost : matrix indexed by [dNodes] of int(0..)
given processes new type enum
given q : int(1..)
given quantity : function (total) Class  --> int(1..n_upperBound),
given quantity : function (total) Material --> int(0..),
given quantity : function (total) Order --> int(1..),
given rowRules : matrix indexed by [dGrid, dRules] of int(0..)
given s : set of int(1..n)
given sizes new domain int
given small, large : set of Farm,
given starting : set (size startingSize) of Peg
given startingSize : int
given Tasks new type enum,
given totalWeight : int(1..1000)
given U new type enum,
given v : int(1..)
given v, b, r, k, lambda_ : int(1..20)
given values  : function (size n) int(1..n) --> int(1..100)
given values  : function (total) int(1..n) --> int(1..100)
given volumeToShip : matrix indexed by [dCargos] of int(1..)
given w, g, s : int(1..)
given weights : function (size n) int(1..n) --> int(1..100)
given weights : function (total) int(1..n) --> int(1..100)
given width      : function (total) Container --> Width,
given x : int
given x : set (size 4) of int(0..9)
given x : set of int(a..b)
given x,y: int
given x_max, y_max, n_shapes : int(1..)
given x_size, y_size : int(1..)
given z : bool
graph((i,j)) = graph((j,i)),
graph((u,v)) != graph((u2,v2)) \/  graph((u2,v2)) !=  graph((v2,u)) \/ graph((v2,u)) != graph((u,v))
graph(i,j)  <->  ! graph(j,i)
graph(_,i,j) = graph(_,j,i),
grid[ l( l(i)[2] )[4,1]  , l( l(i)[2] )[4,2]  ]
grid[ l(i)[4,1], l(i)[4,2] ] =
grid[(startingIndexes[ruleIndex] + colRules[column][ruleIndex])][column] = 0) )
grid[(startingIndexes[ruleIndex])-1][column] = 0)
grid[row][(startingIndexes[ruleIndex] + rowRules[row][ruleIndex])] = 0) )
grid[row][(startingIndexes[ruleIndex])-1] = 0)
hexagon[i + max({0,o-r}), r - max({0,o-(i + max({0,o-r}))})]) = s,
hexagon[i + max({0,r-o}), r - max({0,(i + max({0,r-o}))-o})]) = s
hexagon[r1,i1] != hexagon[r2,i2],
Hole be domain tuple (X,Y),
i % j = 0 -> j in divisors(j)
i <= plan_len .
i <= plan_len-1 .
i = 0 -> j = 1
i in defined(plan),
i subsetEq x
i=j
Index be domain int(1..8)
Index be domain int(1..n_pieces),
int (3)
int(0),
int(1),
int(1,2)
int(1,2),
int(10..13)
int(10..14)
int(11,12)
int(14),
int(2),
int(2,3,4)
int(3)
int(3),
int(4)
int(4),
int(4,5)
int(5)
int(8,9)
int(a..b) -->
inter : function tuple (Place,Place) --> tuple (int(1..n_upper),int(1..n_upper)),
Interval be domain int(1..n-1)
i[1][1] != i[2]
i[1][1] != i[2][1]
i[1][1] in i[2]
j(1) = -1
l(i)[1] = Add ->
l(i)[1] = Modulo ->
language ESSENCE 1.2.0
language ESSENCE 1.3
language ESSENCE 1.3.0
language ESSENCE 2.0
length     : function (total) Container --> Length,
Length    be domain int(1..deck_length),
letting
letting  Colour be domain int(1..colours)
letting  Colour be domain int(1..n)
letting  Vertex be domain int(1..n)
letting all be
letting alphabet be new type of size g
letting Arg be domain int(1..numClues)
letting Ball be domain int(1..n_balls)
letting Base be new type enum {A,C,G,T},
letting Bin be new type of size (sum m : Material . quantity(m))
letting Boat be domain int(1..n_boats)
letting bound be 2 ** n
letting Bucket be domain int(1..nBuckets),
letting capacity be function (1 --> 8, 2 --> 5, 3 --> 3)
letting Cell  be domain tuple (Index,Index)
letting Character be domain int(1..numChars)
letting Clue be domain int(1..numClues)
letting Colour be domain int(1..n_colours)
letting Colour be domain int(1..n_colours),
letting Container be domain int(1..n_containers),
letting container_size be sum i : sizes . 1
letting Course be domain int(1..n_courses),
letting dAllCargos be domain int(0..numCargos)
letting dAllPeriods be domain int(0..numPeriods)
letting dat be
letting dCargos be domain int(1..numCargos)
letting dColours be domain int(0..colours-1)
letting dElement be domain int(1..q)
letting dGates be domain int(1..numGates)
letting dGatesZero be domain int(0..numGates)
letting dGrid be domain int(1..nGrid)
letting dGridSize be domain int(1..gridSize)
letting dHintFormat be domain int(1..2)
letting dHintGrid be domain int(1..numHints)
letting digit be domain int(0..9)
letting digits be domain int(0..9)
letting dIndivHint be domain int(1..maxHintCells)
letting dLeaves be domain int(1..numLeaves)
letting dNodes be domain int(1..numNodes)
letting dNum be domain int(1..n)
letting Dom be domain int(0..6)
letting dom be domain int(0..n-1)
letting Dom be domain int(1..n)
letting dPeriods be domain int(1..numPeriods)
letting dPower be domain int(0..maxPower)
letting dRules be domain int(1..maxRules)
letting dSequnce be domain int(1..q*lam)
letting dSolutionGrid be domain int(1..gridSize*gridSize)
letting dTanks be domain int(1..numTanks)
letting e be new type enum { foo, bar, baz }
letting end  be (3,3)
letting F be domain function (total) int(1..3) --> set of int(1,2)
letting f be function(3 --> {}, 2 --> {1},  1 --> {2,1})
letting Farm be domain int(1..n_farms+1)
letting Flight be domain int(1..n_flights)
letting Flight be domain int(1..n_flights),
letting foobarbaz be new type enum { foo, bar, baz }
letting goal be function (1 --> 4, 2 --> 4, 3 --> 0)
letting Golfers be new type of size g * s
letting hintSumIndex be maxHintCells + 1
letting hole be (3,3)
letting Index  be domain int(1..n*k)
letting Index be domain int(0..container_size-1)
letting Index be domain int(1..2)
letting Index be domain int(1..3)
letting Index be domain int(1..3*n),
letting Index be domain int(1..codeWordLength),
letting Index be domain int(1..n)
letting Index be domain int(1..n),
letting Index be domain int(1..n+2)
letting Index be domain int(1..wordLength)
letting Index be domain int(e..f)
letting Index be domain mset (size 2) of int(1..2)
letting Index be domain set (size 2) of int(1..2)
letting Index be new type of size indexSize
letting Lot be domain tuple (Order,int(1..batch_size)),
letting Material be new type enum {glass,plastic,steel,wood,copper},
letting Material be new type enum {glass,plastic}
letting maxSteps be 31
letting Model be domain int(1..n_models),
letting n be 5
letting nb be n*(n-1) / 6
letting nBuckets be 3
letting Nodes be domain int(1..nnodes)
letting Num be domain int(0..31)
letting Num be domain int(0..maxSteps)
letting Num be domain int(0..n-1),
letting Num be domain int(1..n)
letting numPegs  be 32
letting num_edges be  (n * (n-1))
letting num_edges be  (n * (n-1)) /2
letting o be d/2 + 1,
letting Obj   be new type of size v,
letting Order be domain int(1..10)
letting Order be domain int(1..10),
letting Order be domain int(1..n_orders)
letting Order be domain int(1..n_orders),
letting p be partition({1,2,3},{4,5,6},{7,8,9})
letting Peg be domain (Dom,Dom)
letting Piece be domain int(1..n_pieces),
letting Place be domain int(1..n_places),
letting Plane be domain int(1..n_planes)
letting Postion be domain (int(1..bound),int(1..bound))
letting quantity be function (glass --> 1, plastic -->2  )
letting queens be new type of size n
letting r be relation( (1,2), (1,3), (2,2) )
letting Range be domain (int (3,4), int(5,6))
letting Range be domain (int(3),int(4))
letting Road be domain int(1..n_roads),
letting s be {
letting S be {1,2,3,4,5,5,6,7,8,8,9,0,1,3,3,3}
letting s be {1,2,3,4}
letting seqIndex be domain int(1..seqLength)
letting seqLength be k * n
letting Shape be domain int(1..n_shapes),
letting Slots  be domain int(1..n_cars),
letting sol be [0,1]
letting Square be domain sizes
letting squares be domain tuple(int(1..n),int(1..n))
letting start    be function (1 --> 8, 2 --> 0, 3 --> 0)
letting State  be domain function (total) Bucket --> Water
letting Store be domain int(1..n_stores),
letting String be domain function (total) Index --> Character
letting switches be new type of size k
letting T be domain
letting T be domain matrix indexed by [int(1..2)] of
letting Team   be new type of size n_teams,
letting test be bar
letting totalWater be 8
letting Type be new type enum  {Add, Modulo}
letting V be domain int(1..3)
letting VCol be new type enum {rx,ry}
letting Vertex be domain int(1..n)
letting wordLength be lam*numChars
letting x be (1, (1,2,3) )
letting X be domain int(1..x_size),
letting xy be x * y
letting y be {{{2,3},{2}}}
Line be domain int(1..10),
Line be domain int(1..n_lines),
line_attr : function (total) Line --> set of Attribute,
line_off : function (total) Order --> Day,
line_on : function (total) Order --> Day,
linkCosts[node][childNode] != 0
lookup(fro) = to
lookup(to) = fro
maint : set of Flight
matrix indexed by [int(1)] of (
matrix indexed by [int(1)] of ( int(12),int(13) ),
matrix indexed by [int(1,2)] of
matrix indexed by [int(1,2)] of (int(10,11), F, int(33,55))
matrix indexed by [int(1,2)] of (int(4,5), int(10,11))
matrix indexed by [int(3..4)] of (int(3,4), bool)
matrix indexed by [int(3..4)] of set (minSize 1) of int(6,8)
matrix indexed by [int(3..4)] of set (size 1) of int(6,8)
matrix indexed by [int(4,5)] of
matrix indexed by [int(6..8)] of
max({north(c1), north(c2)}) - min({south(c1), south(c2)})
max({north(c1), north(c2)}) - min({south(c1), south(c2)}) >= 0
max({pair1_1, pair1_2}) - min({pair1_1, pair1_2}) !=
max({pair2_1, pair2_2}) - min({pair2_1, pair2_2})
max({west(c1), west(c2)}) - min({east(c1), east(c2)})
max({west(c1), west(c2)}) - min({east(c1), east(c2)}) >= 0 \/
max({x(s1),x(s2)}) - min({x(s1)+s1,x(s2)+s2}) >= 0 \/
max({y(s1),y(s2)}) - min({y(s1)+s1,y(s2)+s2}) >= 0
maxcars  : function (total) Option --> int(1..n_upperBound),
maximising (sum i in picked . values(i) )
maximising (sum i in x . i) + (sum i in y . i)
maximising (sum i,j : dGridSize . clickMatrix[i][j])
maximising (sum tank : dTanks . (allocation[tank] = 0))
maximising min(x)
maximising sum i in packed . value(i)
maximising sum i in toSet(r(1,_)) . i[1]
maximising sum tuple (i) in toSet(r(1,_)) . i
maximising y
maximising |alive|
maximising |black| + |white|
maximising |words|
maxsum be sum i : int(maxval + 1 - d..maxval) . i,
maxval be 3 * o**2 - 3 * o + 1,
max_connects : function (total) Model --> int(1..5000),
milk : function (total) Farm --> int(0..)
milk(1) = 0
minDist : int(0..maxDist * codeWordLength)
minimising (sum i : dNodes . nodeBroadcastPower[i])
minimising (sum i : int(1..|odd|-1) . distance({odd(i),odd(i+1)}))
minimising (sum r in range(open). opencost(r)) + sum s : Store . cost((s,open(s)))
minimising (sum t : dPeriods . (sum i : dNodes . (holdingCost[i] * stock[i][t] + procCost[i] * (orders[i][t] > 0))))
minimising max(range(packing))
minimising max(Ticks)
minimising plan_len
minimising sum (_,os) in toSet(cut) . os
minimising sum i in x . i
minimising sum k : int(1..n) . (sum i : int(1..n-k) . seq(i) * seq(i+k)) ** 2
minimising sum r in defined(model) . price(model(r))
minimising sum ring in network . |ring|
minimising x
minimising y
minimising |defined(colour)|
minimising |faultyGates|
minimising |hosts|
minimising |parts(sched)|
minimising |range(packing)|
mmtm[1,4][1] = true,
mmtm[1,4][2] = 3,
mmtm[1,4][3][0] = 12
mmt[1,4][1] = true,
mmt[1,4][2] = 3,
Move be domain tuple (Hole,Hole)
moves : function int(1..|board|-1) --> Move
N = sum i in nums . i
n = |S|
node in totalChildrenMatrix[node]
nodeBroadcastPower[node] >= linkCosts[node][childNode]
north(c1) != north(c2)
north, south : function (total) Container --> Y
numberMapping(boxColumn + ((boxRow-1)*gridSize)) = solutionGrid[(gridColumn*gridSize) + boxColumn][(gridRow*gridSize) + boxRow]
numOfCodeWords : int(1..)
n_colours in defined(stuff)
n_colours in stuff
odd(1) = 1,
of matrix indexed by [int(6..8)]  of int(10..13)
opencost : function (total) WHouse --> int(1..n_upper),
Option be domain int(1..n_options)
ordCol : function (total) Order --> Colour
ordcol : function (total) Order --> int(1..10)
Order be domain int(1..n_orders)
p =  partition( { {1,2,3} }
p =  partition({9}, {5, 6, 7, 8}, {1, 2, 3, 4})
p(1) != 1
P(q_1)[1] != P(q_2)[1]                          /\      $ different rows
P(q_1)[2] != P(q_2)[2]                          /\      $ different cols
P(q_2)[1] - P(q_1)[1] != P(q_1)[2] - P(q_2)[2]          $ different upward diagonals
P(q_2)[1] - P(q_1)[1] != P(q_2)[2] - P(q_1)[2]  /\      $ different downward diagonals
pain[1,1] = [6,8]
pain[1,2][1]    = (1,4),
pain[1,2][1][3] = (true,false)
pain[1,2][1][3] = 6,
pain[1,2][2]    = 8,
pain[1,3][1][1] = 2,
pain[1,3][1][1] = {2},
pain[1,3][1][1][1] = {2},
pain[1,3][1][1][2] = {5},
pain[1,3][1][2]    = 3,
pain[1,3][1][2] = {5},
pain[1,3][1][3] = 7,
pain[1,3][2]    = 8,
pain[1,3][2]    = {8},
pain[1,3][2] = 8,
pain[1] = ({3}, {(1,5)}),
pain[1] = 2
pain[1] = 2,
pain[1] = tuple (5),
pain[1] = [ (12,13) ],
pain[1][1]  = 4,
pain[1][1] = (1,9,3,4),
pain[1][1] = (4,7),
pain[1][1] = (5,10),
pain[1][1] = (5,6),
pain[1][1] = (5,6,7,8),
pain[1][1] = (8,3),
pain[1][1] = 1,
pain[1][1] = 2,
pain[1][1] = 5,
pain[1][1] = tuple (5),
pain[1][1] = [ (12,13) ],
pain[1][1] = {5},
pain[1][1][1] = 2
pain[1][1][1] = 2,
pain[1][1][1] = {2},
pain[1][1][1] = {{2}},
pain[1][1][2] = (4, (5,6)),
pain[1][1][2] = (4, 5),
pain[1][1][2] = (5),
pain[1][1][2] = 3,
pain[1][1][2] = 5,
pain[1][1][2] = tuple (5),
pain[1][1][2] = [(4,10),(5,11)],
pain[1][1][3] = (true,false)
pain[1][1][3] = (true,false,true)
pain[1][1][3] = (true,false,true,4)
pain[1][1][3] = (true,false,true,4,5)
pain[1][1][3] = (true,false,true,4,5,6)
pain[1][1][3] = 4,
pain[1][1][3] = tuple (true)
pain[1][1][4] = 5
pain[1][2]    = 8,
pain[1][2]    = {8},
pain[1][2] = ( (10,11),12)
pain[1][2] = ( (10,11),12),
pain[1][2] = (1,2),
pain[1][2] = (1,9,3,4),
pain[1][2] = (14,15)
pain[1][2] = (5,6),
pain[1][2] = (5,6,7),
pain[1][2] = (5,6,7,8)
pain[1][2] = (5,6,7,8),
pain[1][2] = (7,3)
pain[1][2] = (7,3),
pain[1][2] = (8,3),
pain[1][2] = 0,
pain[1][2] = 3,
pain[1][2] = 8,
pain[1][2] = 9
pain[1][2] = tuple (5),
pain[1][2] = tuple (5,10),
pain[1][2] = tuple(5),
pain[1][2] = [ (12, [(55,28),(99,31) ] ), (12, [(55,28),(99,32) ] ) ],
pain[1][2] = [ (12,13) ],
pain[1][2] = [( [ (12,13)],  (14,15)  )],
pain[1][2] = {8},
pain[1][2] = {9},
pain[1][2](1) != -1,
pain[1][3] = ( (10,11),12)
pain[1][3] = ( (10,11),12),
pain[1][3] = (10,11)
pain[1][3] = (10,11),
pain[1][3] = (11,13)
pain[1][3] = (11,13),
pain[1][3] = (14,15)
pain[1][3] = (15, 16, 17, 18)
pain[1][3] = (3,4)
pain[1][3] = (3,4),
pain[1][3] = (5,6),
pain[1][3] = (5,6,7,8),
pain[1][3] = (7,2),
pain[1][3] = (7,3)
pain[1][3] = (7,3),
pain[1][3] = 14,
pain[1][3] = 3
pain[1][3] = 4,
pain[1][3] = 9,
pain[1][3] = tuple (10)
pain[1][3] = tuple (5)
pain[1][3] = tuple (5),
pain[1][3] = tuple(6)
pain[1][3] = tuple(6),
pain[1][3] = { ( [ (12,13)],  (14,15)  )}
pain[1][3] = {6},
pain[1][3] = {9},
pain[1][4] = ( (10,11),12)
pain[1][4] = ( (10,11),12),
pain[1][4] = (12,14),
pain[1][4] = (5,6)
pain[1][4] = (5,6),
pain[1][4] = (6,8,0)
pain[1][4] = (7,3),
pain[1][4] = 10,
pain[1][4] = 3
pain[1][4] = 3,
pain[1][4] = 4,
pain[1][4] = 7,
pain[1][4] = tuple(8)
pain[1][4] = tuple(8),
pain[1][4] = { (15,16)}
pain[1][4] = {5},
pain[1][5] = (1,15)
pain[1][5] = (7,8)
pain[1][5] = (7,8),
pain[1][5] = 11,
pain[1][5] = 14,
pain[1][5] = tuple(3)
pain[1][5] = {4},
pain[1][6] = (12,13)
pain[1][6] = (9,10),
pain[1][6] = 12,
pain[1][6] = { (15,16)}
pain[1][7] = (11,12)
pain[2,2][1][3] = 1,
pain[2,3][1][1] = {1},
pain[2,3][1][1][1] = {1},
pain[2,3][1][1][2] = {4},
pain[2,3][1][2]    = 6,
pain[2,3][1][2] = {4},
pain[2,3][1][3] = 2,
pain[2,3][2]    = 9,
pain[2,3][2]    = {9},
pain[2] = (14,15)
pain[2] = ({1}, {(2,6)}),
pain[2] = 3
pain[2] = tuple (5),
pain[2][1] = 1,
pain[2][1][1] = 1,
pain[2][1][1] = 2,
pain[2][1][1] = 3,
pain[2][1][1] = {1},
pain[2][1][1] = {{1}},
pain[2][1][2] = (4),
pain[2][1][2] = 4,
pain[2][1][2] = tuple (4),
pain[2][1][2] = [(4,10),(5,11)],
pain[2][2]    = 9,
pain[2][2]    = {9},
pain[2][2] = tuple (4),
pain[2][2] = tuple (4,11),
pain[2][2] = [ (12, [(55,28),(99,31) ] ), (12, [(55,28),(99,33) ] ) ]
pain[2][3] = (8,2),
pain[2][4] = (3,true)
pain[3][1] = 2,
pain[3][1][1] = 4
pain[3][2] = tuple (4),
pain[3][2] = tuple (4,12),
pain[3][3] = (7,2)
PCol be new type enum {pr,pg}
Period be domain int(1..n_periods)
Period be new type of size n_teams/2
plan(1) = init,
plan(1) = start,
plan(|plan|) = goal
plan(|plan|) = goal,
Plane be domain int(1..n_planes)
plan_len = |plan|,
plastic in contents(b),
Player be domain int(1..n_players)
plays_in : relation of (Player*Piece)
plugged : function Rack --> set of Card
price        : function (total) Model --> int(1..5000),
q * freq(batches(b),(o,q))) = quantity(o),
r(1,2),
r(1,2,3),
Rack  be new type of size n_racks
relation (size ((n_teams-1)*n_teams)/2) of
req_attr : function (total) Order --> set of Attribute,
req_attr(o) subsetEq batch_attr(b),
req_attr(o) subsetEq line_attr(l),
req_power    : function (total) Type  --> int(1..5000),
s : int(1..maxsum)
s : int(1..sum i : int(n**2+1-n..n**2) . i)
s(b) <= capacity(b),
s, v : function (total) U --> int (1..),
sched : set (size n_periods) of function (total) Boat --> Boat
schedule : function (total, injective) tuple (Line,Day,Slot) --> Batch
separation : function (total) set (size 2) of Class --> int(0..n_upper)
seq(i) = seq(j) -> seq(i) = j - i - 1
seqA = seqB
set (maxSize 4) of int(0..9)
set (minSize 1, maxSize 3) of
set (minSize 4) of
set (size 1) of
set (size 1) of (
set (size 1) of (int(15),int(16))
set (size 1) of int(1,2),
set (size 1) of set (size 1) of int(1,2),
set (size 1) of tuple (int(12,13) )
set (size 2) of
set (size 2) of (int(10,11),int(12,13) )
set (size 2) of (int(10,11),int(12,13) ),
set (size 2) of int(0..),
set (size 2) of int(c..d)
set (size 2) of set (size 3) of int(1..9)
set (size 3) of
set (size 4) of
set (size 4) of int(0..9)
set (size n) of
set (size n) of int(a..b)
shifts : set of set of Tasks
Slot be domain int(1..10),
Slot be domain int(1..n_slots)
south(c) - north(c) = length(c)) \/
south(c) - north(c) = width(c))
Square be domain tuple (Index,Index)
startingIndexes[ruleIndex] > startingIndexes[ruleIndex - 1])
State  be domain function (total) Bucket --> Water
steps(31) = {end},
stock[i][0] = 0
stock[i][t] = stock[i][t-1] + orders[i][t] - (sum m in children[i] . orders[m][t])
stock[i][t] = stock[i][t-1] + orders[i][t] - demand[i][t]
String be domain function (total) Index --> Character
such that (sum i in packed . weight(i)) <= capacity
such that 3 in x
such that a != b
such that a = { x / y @ such that y != 0 }
such that a = { x @ find x : int(0..9)
such that a intersect b = c
such that a subset x
such that a subsetEq x
such that exists i : int(8, 3, 2, 7) . foo[i] /\ i = 2
such that f(1) = 7
such that forAll ((i,j),k) in toSet(g) . f((i,j)) = k
such that forAll (i,j) in all . x(i,j)
such that forAll b1,b2,b3 : Ball . forAll s in parts(schur) .
such that forAll c in valid . forAll rd : Road .
such that forAll i : int(1..3) . f(i) = f(f(i))
such that forAll i : int(1..3) . f(tuple(i,i)) = i + i
such that forAll i : int(1..n-1) . v(i) = |s(i+1) - s(i)|
such that forAll i in a intersect b . i <= 3
such that forAll i in x . i > 4
such that forAll r in rs . r(1,2)
such that forAll r in rs . |toSet(r(2,_))| = 3
such that forAll s in parts(sched) . s in shifts
such that forAll w : WHouse . |preImage(open,w)| <= capacity(w)
such that max({a, 3 - max({a, 3 - r})}) = s
such that pain = [(4, 10), (5, 11);int(1,2)]
such that s in parts(p)
such that seq = function(1 --> -1, 2 --> -1, 3 --> 1)
such that steps = {end}
such that x != e1, x != e2, x = e3
such that x != y
such that x + y = z
such that x = 1
such that x = 3
such that x = 5!
such that x = a intersect b
such that x = all
such that x = foo
such that x = mset(1,1,2)language Essence 1.3
such that x = mset(4,4,5,5,5,6)
such that x = sum (i,j) in starting . i + j
such that x = sum s : set of int(1..5) . toInt({2,3} subsetEq s)
such that x = {relation(), relation((2, 3))}
such that x = |20 - a!|!
such that x = |e| / 2
such that y = 4
such that |a intersect b| = c
such that |fs| = 1
such that |f| = 2
such that |toSet(r(2,_)) intersect toSet(r(4,_))| = 3
such that |x| = 3
sum (l,s) in defined(schedule)(_,d,_) . (a in batch_attr(schedule((l,d,s))))
sum (q) in toSet(batches(b))(o,_) .
sum o : Order . (quantity(o)),
to  in steps(i+1) /\ !(to in steps(i) )
to  in steps(i+1) /\ !(to in steps(i) )     /\
toInt(z) < x + y
totalChildrenMatrix[childNode] subsetEq totalChildrenMatrix[node]
totalCost = totalCost_a + totalCost_b,
totalCost_a = 10,
totalCost_b = 10
true
true in s
tuple (
tuple ( (
tuple ( matrix indexed by [int(3)] of (bool,bool) )
tuple ( matrix indexed by [int(3)] of (bool,bool,bool) )
tuple ( matrix indexed by [int(3)] of (bool,bool,bool,int(4)) )
tuple ( matrix indexed by [int(3)] of (bool,bool,bool,int(4),int(5)) )
tuple ( matrix indexed by [int(3)] of (bool,bool,bool,int(4),int(5),int(6)) )
tuple ( matrix indexed by [int(3)] of tuple (bool) )
tuple ( set(size 1) of int(5) )
tuple ( tuple(
tuple (int(1),int(15))
tuple (int(10))
tuple (int(11),int(13)),
tuple (int(11,12),int(13,14))
tuple (int(12),int(14)),
tuple (int(3))
tuple (int(4,5))
tuple (int(4,5)),
tuple (int(4,5),int(10)),
tuple (int(4,5),int(10,11,12)),
tuple (int(5)),
tuple (int(6,7))
tuple (int(6,7)),
tuple (int(7,8),int(2,3))
tuple (int(7,8),int(2,3)),
tuple (int(8,9))
tuple (int(8,9)),
tuple (x) in r(1,_)
tuple(set of int(3..4), tuple(int(3..4), bool) ) )
tuple({6,7}) in x
tuple({6,7},3,{9}) in x
Type  be domain int(1..n_types),
usage    : relation of ( Class * Option )
v : function (total, bijective) int(1..n-1) --> Interval
Value be domain int(1..maxval)
Value be domain int(1..n**2)
VCol be new type enum {r,ry,g,y},
VCol be new type enum {rx,ry},
vols    : function (total) items --> int(1..bin_vol)
w1(i) = C /\ w2(9-i) = G \/
w1(i) = G /\ w2(9-i) = C \/
w1(i) = T /\ w2(9-i) = A)
Water  be domain int(0..totalWater),
Week   be new type of size n_teams-1,
weight,value : function (total) Items --> int (1..)
where
where    n % 6 = 1
where (sum s : sizes . s**2) = container_size**2
where 2 = 2
where d % 2 = 1
where forAll h in init union goal . h in board
where k>=t, b>=g**t
where n >= 0
where n%2 = 0
where n_teams % 2 = 0
where r = k
where v = b
where x < y
where x > 0
WHouse be domain int(1..n_warehouses)
Width     be domain int(1..deck_width),
Word be domain int(1..n_words),
X         be domain int(0..deck_width),
x  = { relation(), relation((2, 3)) }
x != 1
x != y
x < a
x = ({3,4} subsetEq {3,4,5,9}),
x = ({3,5} subsetEq {3,4,5,9}),
x = ({4,4} subsetEq {3,4,5,9}),
x = 3
x = 3*y,
x = a
x = a + b + c + d
x = a union b
x = mset(4,4,5,5,5,6)
x = sum (i,j) : (int(1..9), int(1..9)) , i < j . j
x = sum (i,j) in toSet(relation( (1,2), (1,3), (2,2) )) , i = 1 . j
x = sum i : int(1..28) . m[i,1] + m[i,2] - m[i,3] - m[i,4]
x = sum m : matrix indexed by [int(1..2), int(1..1)] of int(1..2) , (forAll i : int(1..2) . allDiff(m[i])) . 1
x = true /\ {3, 4} subsetEq {3, 4, 5, 9} /\ {3, 5} subsetEq {3, 4, 5, 9} /\ {4, 5} subsetEq {3, 4, 5, 9},
x = ylanguage ESSENCE 1.3
x = {2,3,4}
x >= dat[1,i]
x >= dat[i,1]
x >= v__101 * blah * v__1
X be domain int(1..x_max),
x subset ylanguage Essence 1.3
x subsetEq a
x subsetEq a,
x subsetEq s,
x subsetEq y
x(1,_,_) = relation((1,1))
xy > 0
x[1] = {6},
x[1][1] = 3,
x[1][1] = 6
x[1][1] = {3},
x[1][1] = {6},
x[1][2] = 6,
x[1][2] = {7},
x[2] = (5,7,9),
x[2] = ({5},7,9),
x[2] = {(5,8),(6,9)}
x[2] = {7,8}language Essence 2.0
x[2][1] = {7,8},
x[2][2] = {8}
Y         be domain int(0..deck_length)
y =
y = (  (1, {2,3}, 4, (5,6, {7,8,9} )))
y = (1,(2,(3,4)))
y = 3*z
y = 4,
y = sum i in x . i,
y = sum {i,j,k} subsetEq x . i * j + k
y = sum {i,j} subsetEq x . i * j
y = tuple ([
y = x
y = [ (10,12), (11,13) ]
Y be domain int(1..y_max),
Y be domain int(1..y_size),
y in x
y in x,
y subsetEq x
z = sum i in x . 1
[ (1,2,3)
[2,3,4;int(0..2)] in x
[a, b] != [d, c]
[a, b] =  [c, d],
\/
\/ n % 6 = 3
]
] of tuple ( bool
])
{ (1,1)
{ y @ find y : int(0..9)
{(10,12), (11,13) }
{(10,12), (11,13) },
{1} subsetEq x,
{2,7,8} subset y
{c(rd),c((rd % n_roads)+1)} in {{(r,pr),(g,pg)},{(ry,pr),(y,pr)}}
{tuple (12)}
| sets[setA] intersect sets[setB] | <= 1
| { [c1,c2], [v1,y1], [x1,u2] }| = 3
|(toSet(graph(i,_) ))|  +  |(toSet(graph(_,i) ))|  = n - 1 /\
|(toSet(graph(_,i,i) ))| = 0,
|(toSet(graph(_,i,j) ))|  +  |(toSet(graph(_,j,i) ))| = 1,
|(toSet(graph(_,i,j) ))|  +  |(toSet(graph(_,j,i) ))| = 2 /\
|(toSet(graph(_,i,j) ))|  = 1 /\
|(toSet(graph(_,i,_) ))|  +  |(toSet(graph(_,_,i) ))|  = 2 * (n - 1) /\
|(toSet(graph(_,i,_) ))|  +  |(toSet(graph(_,_,i) ))|  = n - 1
|(toSet(graph(_,i,_) ))|  +  |(toSet(graph(_,_,i) ))|  = n - 1 /\
|(toSet(graph(_,i,_) ))| = (n - 1) /\
|(toSet(graph(_,j,i) ))|  = 1 /\
|(toSet(graph(_,_,i) ))| = (n - 1) /\
|arrangement(q1) - arrangement(q2)| != |q1 - q2|
|black| = |white|,
|directChildrenMatrix[i] intersect directChildrenMatrix[j]| = 0
|fs| = 1
|group1 intersect group2| < 2
|plan(i) intersect plan(i+1)| = 1,
|plugged(r)| <= max_connects(model(r))
|s1 intersect s2| = y - x
|setA intersect setB| = 0
|setA union setB| = n
|steps(i) intersect steps(i+1)| = |steps(i)| - 2,
|steps(i)| = numPegs - i  /\
|toSet(r(1,2,_))| = 3,
|toSet(r(1,_,3))| = 3,
|toSet(r(1,_,_))| = 3,
|toSet(r(2,_))| = 3,
|toSet(r(_,2,3))| = 3,
|toSet(r(_,2,_))| = 3,
|toSet(r(_,4))| = 5
|toSet(r(_,_,3))| = 3,
|totalChildrenMatrix[initialNode]| = numNodes
|x union y| = 3,
|x1-x2| = 0 /\ |y1-y2| = 2,
|x| = 1
|x| = y,
|x| in x
|{i, i+ 1}| in a
}
}
