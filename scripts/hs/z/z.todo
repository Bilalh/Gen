|defined(function(function(0 --> -8) --> {true, false}))|

bar 0
    defined 1
        function 2
            function 3
                0    4
                8    4
            set        3
                true   4
                false  4

|{  (2, -7),   [true, true; int(4, 2..2)] }|



defined
    function
        int -> _




type conversion

    ☐ functions
        ☐ freq
        ☐ hist
        ☐ max
        ☐ min
        ✔ toInt @done(2014-11-12 04:02)
        ☐ toMSet
        ☐ toRelation
        ☐ toSet
        ☐ defined
        ☐ image
        ☐ inverse
        ☐ preImage
        ☐ range
        ☐ apart
        ☐ parts
        ☐ party
        ☐ together

    ☐ Uops
        ✔  | | @done(2014-11-12 04:02)







fromNested basic:
    ✔ tuple @done(2014-11-05 05:41) @project(fromNested)
    ✔ function  @done(2014-11-05 05:41) @project(fromNested)
    ✔ matrix  @done(2014-11-05 05:41) @project(fromNested)
    ☐ set
    ☐ mset
    ☐ relation
    ☐ partition
    ☐ enums

fromNested  functions:
    ☐ tuple
    ☐ function
    ☐ matrix
    ☐ set
    ☐ mset
    ☐ relation
    ☐ partition
    ☐ enums

fromNested  complete:
    ☐ tuple
    ☐ function
    ☐ matrix
    ☐ set
    ☐ mset
    ☐ relation
    ☐ partition
    ☐ enums


matrixes:
    ☐ need size in the type?


Boolean expr:
    ✔  boolLit @done(2014-10-31 09:45)
    ✔  equivExpr @done(2014-10-31 09:45)
    ✔  relationExpr @done(2014-10-31 09:45)
    ☐  set stuff
    ☐  lex stuff

tasks:
    ✔  literals (apart from enums and unamed) @done(2014-10-31 03:40)

    ☐  enums and unnamed domains
    ☐  enums and unnamed literals

    ☐  forall/exist  i  in var
        ✔ started @done(2014-10-31 05:29) @project(    tasks)
        ☐ all

    ☐  forall/exist  i  : dom
        ✔ started @done(2014-10-31 05:29) @project(    tasks)
        all

    ☐  guards
        ✔  started @done(2014-10-31 05:28) @project(    tasks)

    ☐ tuple indexing
        ✔ beConstant_ flag @done(2014-10-31 11:09)


    ☐ quan sum
        ✔  mostly @done(2014-10-31 05:29) @project(tasks)

    ☐ binop
        ☐ In
        ☐ Over
        ✔ EQ @done(2014-10-31 05:35) @project(tasks)
        ✔ NEQ @done(2014-10-31 05:35) @project(tasks)
        ☐ LT
        ☐ LTE
        ☐ GT
        ☐ GTE
        ✔ Plus @done(2014-10-31 05:34) @project(tasks)
        ✔ Mult @done(2014-10-31 05:34) @project(tasks)
        ✔ Div @done(2014-10-31 05:34) @project(tasks)
        ✔ Pow @done(2014-10-31 05:34) @project(tasks)
        ✔ Mod @done(2014-10-31 05:34) @project(tasks)
        ✔ And @done(2014-10-31 05:34) @project(tasks)
        ✔ Or @done(2014-10-31 05:34) @project(tasks)
        ✔ imply @done(2014-10-31 05:34) @project(tasks)
        ✔ iff @done(2014-10-31 05:34) @project(tasks)
        ☐ subset
        ☐ subsetEq
        ☐ supset
        ☐ supsetEq
        ☐ intersect
        ☐ union
        ☐ lexLT
        ☐ lexLTE
        ☐ lexGT
        ☐ lexGTE

{{    ☐ functions
        ☐ freq
        ☐ hist
        ☐ max
        ☐ min
        ☐ toInt
        ☐ toMSet
        ☐ toRelation
        ☐ toSet
        ☐ defined
        ☐ image
        ☐ inverse
        ☐ preImage
        ☐ range
        ☐ apart
        ☐ parts
        ☐ party
        ☐ together
    ☐ SR functions}}

    ☐  0 length matrix?  e.g [; int]
    ☐  0 length tuple?






such that
    [false, false, false, true, true, false, true, false, false, false,
     false; int(2..10, 1..5, -6)]
    !=
    [true, false, true, true, true, true, true, true, false, false,
     true, false; int(-7, 5..8, -2..7)]
    ->
    false



[3, 9, 7, 5, -9; int(-2, -6..-6, -8..-5)]

-2
-6
-8
-7
-6
-5



sum contraints like

    (sum i : int(1.2) . j ) > 2

`methods`  like max, min etc

bubbles, or are these just impl detail?


remove causes that make the spec obviously insoluable?



want to be able to specify have like nesting occurs, for example for guards on quan, should in general not be nested too much

2014-10-08:

`exprUsingRef`  some possible ideas @done(2014-10-09 03:11)

we know the type `t` of  ref

choose the op  first e.g

    _1  =  _2

choose the type of _1 to be a type that can be reached from `t` using n levels of expressions e.g

| t's type        | selected type | how               | depth |
|:----------------|:--------------|:------------------|:-----:|
| set of int      | int           | :ref:             |   1   |
| int             | set of int    | {ref}             |   1   |
| Func int -> int | (a,b)         | (ref[0], ref[1] ) | 2 + ? |



then generating expression of the resulting type for _2  as normal

having the ref in _2 would also work

Probably want to exclude expressions `simple` identities  ref = ref


another thing that would be useful is to focus on certain type.
e.g. I changed some a set repr so I want to generate some test cases involving set


2014-10-06:
✔ Add quan variables to mapping (FG) @done(2014-10-08 02:04)

2014-10-03:
✔ set equals  should use the same type of both sizes @done(2014-10-03 01:28)
✔  when to subtract? @done(2014-10-03 01:28)
✔  Need a separate type for `Any Domain` @done(2014-10-05 01:34)
✔  Need a better type unifier @done(2014-10-05 01:34)



2014-09-29:
✔ Domains and literals can have `expr` in them. @before(2014-10-03 12:02)
☐ Make sure all variables are used?


2014-09-24:
☐ Once we have an arbitrary domain, generate a expression of that type, any at this point.
    ✔ Set, kind of @done(2014-09-25 02:03)
✔ Do more operators @done(2014-09-25 02:03)
☐ Make easily runnable on host
    ✔  kind of @done(2014-09-25 02:03)


2014-09-23:
☐ Once we have an arbitrary domain, generate a expression of that type, any at this point.
    ✔  Int @done(2014-09-24 05:29)
    ✔  Bool @done(2014-09-24 03:19)
    ✔  References @done(2014-09-24 05:00)

✔ Look into into Quantification @done(2014-09-24 03:16)
    ✔  Got a foralls  example working @done(2014-09-23 03:55)
☐ Investigate references in domains bounds.
    Could just make it a take an `Expr` but not type safe
☐ Determine a sensible way of increasing nesting.
    ✔  for a start just passing a depth directly @done(2014-09-23 03:54)

＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿




If using quick-check's monad, we need a way of passing state about.  The problem is that it takes no arguments.

    arbitrary :: Gen a

We could use our own arbitrary

class Arbitrary a => ArbitrarySized a where
    arbitrarySized :: Int ->  Gen a
    arbitrarySized _ = error "no default sized generator"

and some kind of state monad

＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿

Archive:
